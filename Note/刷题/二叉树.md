##　二叉树专题

#### 1.[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

(根左右)

+ 模板题．简单的二叉树前序列遍历．
+ 可以用递归，也可以用栈，用栈时间复杂度低．
  - 尽可能往左边找，左边没有才会弹出栈中元素．

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> pp;
    vector<int> preorderTraversal(TreeNode* root) 
    {
        stack<TreeNode*> ans;
        while(!ans.empty() || root != NULL)
        {
            while(root!=NULL)
            {
                pp.push_back(root->val);
                ans.push(root);
                root = root->left;
            }
            root = ans.top();
            ans.pop();
            root = root->right;
        }
        return pp;
    }
};
```

```c++
class Solution {
public:
    vector<int> pp;

    void PreOrder(TreeNode * root)
    {
        if(root!=NULL)
        {
            pp.push_back(root->val);
            PreOrder(root->left);
            PreOrder(root->right);
        }
        return;
    }
    
    vector<int> preorderTraversal(TreeNode* root) 
    {
       PreOrder(root);
       return pp;
    }
};
```

#### 2.[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

(左根右)

+ 与上题目类似，不仅可以递归，也可以用栈做．

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> pp;
    vector<int> inorderTraversal(TreeNode* root) 
    {
       stack<TreeNode*> ans;
       while(root!=NULL || !ans.empty())
       {
           while(root!=NULL)
           {
               ans.push(root);
               root = root->left;
           }
           root = ans.top();
           pp.push_back(root->val);
           ans.pop();
           root = root->right;
       } 
       return pp;
    }
};
```

```c++
class Solution {
public:
    vector<int> pp;
    void InOrder(TreeNode* root)
    {
        if(root!=NULL)
        {
            InOrder(root->left);
            pp.push_back(root->val);
            InOrder(root->right);
        }
        return;
    }

    vector<int> inorderTraversal(TreeNode* root) 
    {
       InOrder(root);
       return pp;
    }
};
```

#### 3.[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

(左右根)

+ 也是模板题目，栈或者递归写法．
+ 对于递归写法，有一个新思路，由于前序遍历是根左右，后序遍历的reverse是根右左.
+ 可以套前序遍历的模板.

```c++
class Solution {
public:
    vector<int> pp;
    vector<int> postorderTraversal(TreeNode* root) 
    {
        stack<TreeNode*> ans;
        while(root!=NULL || !ans.empty())
        {
            while(root!=NULL)
            {
                pp.push_back(root->val);
                ans.push(root);
                root=root->right;
            }
            root = ans.top();
            ans.pop();
            root = root->left;
        }
        reverse(pp.begin(),pp.end());
        return pp;
    }
};
```

```c++
class Solution {
public:
    vector<int> pp;
    void PostOrder(TreeNode* root)
    {
        if(root!=NULL)
        {
            PostOrder(root->left);
            PostOrder(root->right);
            pp.push_back(root->val);
        }
        return;
    }
    vector<int> postorderTraversal(TreeNode* root) 
    {
        PostOrder(root);
        return pp;
    }
};
```

#### 4.[173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

+ 迭代器，就是泛型指针．可以访问容器中的元素．

+ **有两种思路**

##### **4.1第一种借用vector**

+ 可以先将二叉搜索树进行中序列遍历，中序列遍历后是一个递增的数组．

+ 然后查找下一个元素，就可以在数组中查找了．

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class BSTIterator {
public:
    vector<int> pp;
    int count = 0;

    BSTIterator(TreeNode* root) {
        PreInorder(root);
    }

    void PreInorder(TreeNode * root)
    {
        stack<TreeNode*> ans;
        while(root!=NULL || !ans.empty())
        {
            while(root!=NULL)
            {
                ans.push(root);
                root = root->left;
            }
            root = ans.top();
            pp.push_back(root->val);
            ans.pop();
            root = root->right;
        }
    }
    
    int next() {
        return pp[count++];

    }
    
    bool hasNext() {
        return count>=pp.size()? false : true;
    }
};

/**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator* obj = new BSTIterator(root);
 * int param_1 = obj->next();
 * bool param_2 = obj->hasNext();
 */
```

##### 4.2第二种

+ 依然是利用二叉树的中序遍历．一直保持左子链完整．
+ 每次获取一次next之后，就要对该和该节点相关的节点全部进入数组．又因为是中序列遍历，所以后面进入数组的元素都比前一个大．

```c++
class BSTIterator {
private:
    vector<TreeNode*> pp;
public:
    BSTIterator(TreeNode* root) {
        while(root!=NULL)
        {
            pp.push_back(root);
            root = root->left;
        }
    }
    
    int next() 
    {
        TreeNode* temp = pp.back();
        pp.pop_back();
        int ans = temp->val;
        temp = temp->right;
        while(temp!=NULL)
        {
            pp.push_back(temp);
            temp = temp->left;
        }
        return ans;
    }
    
    bool hasNext() 
    {
        return !pp.empty();
    }
};
```

#### 5.[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

+ bfs,采用队列进行层序遍历．

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> pdd;
    vector<vector<int>> levelOrder(TreeNode* root) 
    {
        queue<TreeNode*> pp;
        if(root!=NULL) pp.push(root);
        while(!pp.empty())
        {
            vector<int>      ans;
            int count = pp.size();
            while(count--)
            {
                TreeNode* temp = pp.front();
                ans.push_back(temp->val);
                pp.pop();
                if(temp->left!=NULL) pp.push(temp->left);
                if(temp->right!=NULL) pp.push(temp->right);
            }
            pdd.push_back(ans);
        }
        return pdd;
    }
};
```

#### 6.[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

+ 和102题目有点类似，对于偶数层来说，我们直接把vector进行reverse操作就可以了．
+ 但是上面这种想法，对于空间的利用有点大，但是题目是可以过得去的．

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    vector<vector<int>> pdd;

public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) 
    {
        queue<TreeNode*> pp;
        int flag=0;
        if(root!=NULL) pp.push(root);
        while(!pp.empty())
        {
            vector<int> ans;
            int count = pp.size();
            while(count--)
            {
                TreeNode* temp = pp.front();
                ans.push_back(temp->val);
                pp.pop();
                if(temp->left!=NULL) pp.push(temp->left);
                if(temp->right!=NULL) pp.push(temp->right);
            }
            if(flag==0)
            {
                pdd.push_back(ans);
                flag=1;
            }
            else
            {
                reverse(ans.begin(),ans.end());
                pdd.push_back(ans);
                flag=0;
            }

        }
        return pdd;
    }
};
```

#### 7.[107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

+ 与102题目类似，不过是把双层vector进行一个reverse而已，模板题目.

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> pdd;
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> pp;
        if(root!=NULL) pp.push(root);
        while(!pp.empty())
        {
            vector<int>      ans;
            int count = pp.size();
            while(count--)
            {
                TreeNode* temp = pp.front();
                ans.push_back(temp->val);
                pp.pop();
                if(temp->left!=NULL) pp.push(temp->left);
                if(temp->right!=NULL) pp.push(temp->right);
            }
            pdd.push_back(ans);
        }
        reverse(pdd.begin(),pdd.end());
        return pdd;

    }
};
```

#### 8.[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

+ 递归的代码，想出来但是写不出来．还是得多练．

##### 8.1第一种**用区间的方法来判断．**(递归)

![截图录屏_选择区域_20210314122242](/home/hchc/Desktop/截图录屏_选择区域_20210314122242.png)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
	//fun函数的作用是判断当前节点root是否在(Left,Right)开区间内.
    //
    int fun(TreeNode* root,long Left,long Right)
    {
        if(root==NULL)
        {
            return 1;
        }
        if(root->val <= Left || root->val >= Right)
        {
            return 0;
        }
        return (fun(root->left,Left,root->val) && fun(root->right,root->val,Right));
    }

    bool isValidBST(TreeNode* root) 
    {
        return fun(root,LONG_MIN,LONG_MAX);
    }
};
```

##### 8.2第二种用中序遍历记录前驱的方法（递归）

```c++
class Solution {
public:
    //记录前一个节点
    TreeNode* pre = NULL;
    bool isValidBST(TreeNode* root) 
    {
        if(root == NULL) return true;
        //递归判断左子树
        bool left = isValidBST(root->left);
		
        if(pre!=NULL && pre->val >= root->val) return false;
        //保存前一个节点
        pre = root;
		//递归判断右子树
        bool right = isValidBST(root->right);
        return left&&right;
    }
};
```

#### 9.[99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)

##### 9.1中序遍历记录前驱(递归)

+ 采用**中序遍历记录前驱**的方法．前驱节点的值小于当前节点的值，则是BST.
+ 否则就要交换两个节点中的值．以满足BST的特点．
+ 要注意的问题点：有一个降序对出现的时候，可以直接交换，但是有两个的话，就要将最左边的值与最右边的值交换．
+ 时间复杂度O(n),空间复杂度O(n)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //记录前驱节点
    TreeNode* pre = NULL;
    //记录最左边的降序节点
    TreeNode* pre1 = NULL;
    //记录最右边的降序节点
    TreeNode* last = NULL;

    void fun(TreeNode* root)
    {
        if(root==NULL) return ;
        fun(root->left);

        if(pre!=NULL && pre->val > root->val) 
        {
           if(pre1 == NULL) pre1 = pre;
           last=root;
        }
        pre = root;
        fun(root->right);
    }
    void recoverTree(TreeNode* root) 
    {
        fun(root);
        int temp = pre1->val;
        pre1->val = last->val;
        last->val = temp;
    }
};
```

##### 9.2morris遍历

+ morris遍历树结点,会将每个结点都访问两遍,O(2n)->O(n)时间复杂度O(n),空间复杂度O(1)

+ 第一次学到这种遍历树的算法,相对于上一种递归方法和非递归的遍历树的方法，它节省了空间.充分的利用了树叶子结点的空指针域．

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      TreeNode* pre = NULL;
      TreeNode* cur,*mostright,*x,*y;
      void recoverTree(TreeNode* root) 
      {
          while(root!=NULL)
          {
              if(root->left!=NULL)
              {
                  mostright = root->left;
                  while(mostright->right!=NULL && mostright->right != root)
                  {
                      mostright = mostright->right;
                  }
  
                  if(mostright->right == NULL)
                  {
                      mostright->right = root;
                      root = root->left;
                  }
                  else
                  {
                      if(pre != NULL && root->val < pre->val)
                      {
                          y=root;
                          if(x==NULL)
                          {
                              x=pre;
                          }
                      }
                      pre = root;
                      mostright->right = NULL;
                      root = root->right;
                  }
              }
              else
              {
                  if(pre != NULL && root->val < pre->val)
                      {
                          y=root;
                          if(x==NULL)
                          {
                              x=pre;
                          }
                      }
                      pre = root;
                  root = root->right;
              }
          }
          swap(x->val,y->val);
      }
  };
  ```


#### 10.[230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

##### 10.1递归方法

+ 将BST中序遍历存入vector中，由BST性质可以知道，是一个升序列．再直接对数组操作即可.
+ 时间复杂度O(N),空间复杂度O(N).

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    void fun(TreeNode* root)
    {
        if(root!=NULL)
        {
            fun(root->left);
            ans.push_back(root->val);
            fun(root->right);
        }
    }


    int kthSmallest(TreeNode* root, int k) 
    {
        ans.reserve(10050);
        fun(root);
        return ans[k-1];  
    }
};
```

###### 10.1.1dfs递归方法:

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans=0;
    int count=0;
    void fun(TreeNode * root,int k)
    {
        if(root!=NULL)
        {
            fun(root->left,k);

            count++;
            if(k==count)
            {
                ans = root->val;
            }

            fun(root->right,k);
        }
    }

    int kthSmallest(TreeNode* root, int k) 
    {
        fun(root,k);
        return ans;
    }
};
```



##### 10.2用栈迭代

+ 与4题第二种方法思想一样.
+ 一直保持该树左子链完整，依次入栈，出栈时，将与出栈节点有关的右子节点入栈.
+ 时间复杂度O(h+k),空间复杂度O(h+k)
+ h+k <= N(树的所有节点)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) 
    {
        TreeNode* temp,*ans;
        stack<TreeNode*> pdd;
        
        while(!pdd.empty() || root!=NULL)
        {
            while(root!=NULL)
            {
                pdd.push(root);
                root = root->left;
            }
            root = pdd.top();
            pdd.pop();
            --k;
            if(k == 0)
            {
                return root->val; 
            }
            root = root->right;
        }
        return 0;
    }
};
```

#### 11.[257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

+ dfs

```c++
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> res;
        if (root == nullptr) return res;

        binaryTreePaths(root, res, "");
        return res;
    }

    void binaryTreePaths(TreeNode * root, vector<string> & res, string path) {
        path += to_string(root->val);

        if (root->left == nullptr && root->right == nullptr) {
            res.push_back(path);
            return;
        }

        if (root->left) binaryTreePaths(root->left, res, path + "->");
        if (root->right) binaryTreePaths(root->right, res, path + "->");
    }
};
```





