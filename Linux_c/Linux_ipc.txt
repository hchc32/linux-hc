IPC:    (InterProcessCommunication)     进程间通信，通过内核提供的缓冲区进行数据交换的机制/

***********阻塞与非阻塞：是文件的属性，而不是函数的属性

1.虚拟内存空间0-3G区域都是每个进程不同的，所以进程间通信是在3G-4G的内核区进行的

2.IPC通信的方式有几种：
        1.管道  (无名)管道---最简单的
        2.信号  ---系统开销小
        3.共享映射区 ---有无血缘关系的进程间通信都可以
        4.本地套接字 ---稳定 (网络编程)
3.管道(匿名管道)
    1.本质：一块内核的缓冲区(也可以理解成伪文件),不占用磁盘空间.
    2.特点：
                1.分为读端，写端，各自对应一个文件描述符.
                    数据写端流入，读端流出.(数据只能单向进行)

                2.操作管道的进程被销毁之后管道自动被释放了.

                3.管道默认是阻塞的
    3.管道的原理：
            内部的实现方式：队列(环形队列)
                            特点： 先进先出
            环形队列的优点：不用每一次都前移，保证效率高.
            缓冲区大小：
                        默认4k.
                        大小会根据实际情况做适当的调整.
    4.管道的局限性：
            1.队列： 数据只能读取一次不能重复读取
            2.传输的方向是单向的
            3.只适用于有血缘关系的进程
    5.创建匿名管道
    函数原型： int pipe(int fd[2]);
    函数所在头文件：#include<unistd.h>
    与wait的参数也一样，是传出参数
            fd - 传出参数
            fd[0] 读端 
            fd[1] 写端
****单个进程也可以用管道完成读写操作
****由于管道默认是阻塞的，所以父子进程间通信不需要sleep函数.
    6.如果不关闭读写端，父进程已经读走数据，子进程会读不到数据，就会处于阻塞状态。  
      
      如果不关闭读写端，子进程写父进程读？？？？
    
    7.兄弟间通信
        兄弟间实现ps aux | grep bash
        父亲-》资源回收
    8.管道的读写行为
        读操作：

            有数据：
                read(fd) 正常读取，返回读出的字节数
        
            无数据：
                写端全部关闭：
                    read解除阻塞，返回0，相当于读到了文件的尾部
                写端没有全部关闭：
                    read处于阻塞状态
        写操作：

            读端全部关闭：
              管道破裂，进程被信号终止
                内核给当前进程发信号SIGPIPE

            读端没有全部关闭：
                
                缓冲区写满了
                    write阻塞，直到读出数据
                
                缓冲区没有满
                    write继续写，直到写满
    9.查看管道缓冲区大小
        
        命令：ulimit -a(也看看到栈的最大空间，文件描述符最大个数等。。。)
        
        函数：fpathconf
            函数原型：long fpathconf(int fd, int name);
            函数所在头文件： #include<unistd.h>
    10.如何设置非阻塞
        
        管道读写两端默认为非阻塞
        
        设置读端为非阻塞pipe(fd[0])
            fcntl - 变参函数
                ～复制文件描述符---类似于dup
                ～修改文件的属性---open时候的属性
            设置方法：
                获取原来的flags（属性）
                int flags = fcntl(fd[0],F_GETTFL);
                设置新的flags
                flags |= O_NONBLOCK;
                fcntl(fd[0],F_SETFL,flags);
            非阻塞设置成功·

































